#reactjs 
```table-of-contents
```
React Hooks - это функции, которые позволяют вам взаимодействовать со состоянием и другими функциями жизненного цикла React из функциональных компонентов, исключая необходимость создавать классовые компоненты. Hooks были введены в React 16.8 и представили новый подход для написания компонентов.

Примеры основных hooks включают `useState`, `useEffect`, и `useContext`:
#### useState
Этот hook позволяет вам добавить состояние в функциональный компонент. `const [state, setState] = useState(initialState);` - возвращает пару текущее значение состояния и функцию для его обновления.
#### useEffect
Этот hook используется для выполнения побочных эффектов в функциональных компонентах. Он может использоваться для различных целей, таких как загрузка данных, подписка на события или работа с DOM напрямую. `useEffect` выполняется после каждого рендеринга, если не указаны зависимости.
#### useContext
Этот hook позволяет вам использовать контекст внутри функционального компонента - `useContext(MyContext)` принимает контекст и возвращает текущее значение этого контекста.

Есть также дополнительные hooks, такие как `useReducer`, `useCallback`, `useMemo`, `useRef`, `useImperativeHandle`, `useLayoutEffect`, и встроенный hook для создания вашего собственного поведения - `useDebugValue`.

Вот простой пример того, как можно использовать hooks в компоненте:

```jsx
import React, { useState, useEffect } from 'react';

function Example() {
  const [count, setCount] = useState(0); // useState hook

  useEffect(() => { // useEffect hook
    document.title = `You clicked ${count} times`;
  });

  return (
    <div>
      <p>You clicked {count} times</p>
      <button onClick={() => setCount(count + 1)}>
        Click me
      </button>
    </div>
  );
}

export default Example;
```

В этом примере `useState` добавляет локальное состояние к функциональному компоненту `Example`, а `useEffect` реагирует на обновления состояния, аналогично `componentDidMount` и `componentDidUpdate` в классовых компонентах.
#### useCallback
Этот хук возвращает мемоизированную версию функции-колбека, которая изменяется только при изменении значений её зависимостей. Это полезно при передаче колбеков оптимизированным дочерним компонентам, чтобы они не выполняли ненужных ререндеров из-за изменения ссылок на функции.

```jsx
const memoizedCallback = useCallback(() => {
    doSomething(a, b);
}, [a, b]);
```
#### useRef
Этот хук создает изменяемый объект (`{current: ...}`), значение которого сохраняется на протяжении всего жизненного цикла компонента. Он обычно используется для хранения ссылок на DOM-элементы.

```jsx
const inputRef = useRef(null);

// внутри компонента
<input ref={inputRef} />
```
#### useMemo
Этот хук возвращает мемоизированное значение. Вы используете его, когда хотите избежать повторных вычислений дорогостоящих функций при каждом рендере.

```jsx
const memoizedValue = useMemo(() => computeExpensiveValue(a, b), [a, b]);
```
#### useReducer
Этот хук предоставляет альтернативный `useState` способ работы со сложным состоянием. Он принимает редуктор (функцию, которая определяет, как состояние должно быть изменено в ответ на действие) и начальное состояние. `useReducer` полезен при работе с большим количеством взаимосвязанных значений состояния или когда следующее состояние зависит от предыдущего.

```jsx
const [state, dispatch] = useReducer(reducer, initialArg, init);
```
#### useImperativeHandle
используется для кастомизации экземпляра, который возвращается при использовании `ref`.
#### useLayoutEffect
ведет себя подобно `useEffect`, но он запускается синхронно после всех мутаций DOM и перед тем, как браузер имеет возможность осуществить рендеринг.
#### useDebugValue
может использоваться для отображения метки для пользовательских хуков в React DevTools.