#angular 
```table-of-contents
```
Для настройки необходимых <font color="#9bbb59">зависимостей</font> Angular предоставляет технологию под названием **Dependency Injection** (внедрение зависимостей).
![[Pasted image 20240125142103.png]]
<font color="#f79646">platform</font> - несколько приложений используют один экземпляр сервиса.
<font color="#f79646">root</font> - все приложение, один экземляр сервиса.
<font color="#f79646">any</font> - доступен в каждом модуле, но для каждого используется свой собственный уникальный экземпляр сервиса (удобно для лейзи лоада модулей).
<font color="#f79646">Type any </font> представляет тип модуля, которому мы хотим предоставить сервис.
 Полезно, когда у вас есть сервис, который должен быть доступен сразу после загрузки определенного модуля.

Добавление декоратора `Injectable` к классу показывает, что он доступен для внедрения и может быть внедрен.
``` typescript
@Injectable()  
class OneService {}
```
Где она может быть внедрена?
1. На уровне <span style="background:#fdbfff">компонента</span>.
``` typescript
@Component({  
selector: 'app-list',  
template: '...',  
providers: [oneService]  
})  
class TestComponent {}
```
2. На уровне <span style="background:#d4b106">модуля приложения</span>.
``` typescript
@Injectable({  providedIn: 'root'  })  
class TestService {}
```
Самый распространенный способ внедрения зависимости — добавление ее в <font color="#9bbb59">конструктор </font>соответствующего компонента, где нужно использовать эту зависимость.
``` typescript
constructor(private loggerService:LoggerService) { }
```

#### Dependency Inversion
Начнём с такого набора принципов, который называется **SOLID**. Каждая буква из этого названия — это первая буква соответствующего принципа. Обратим внимание на последний принцип **Dependency Inversion** «Инверсия зависимостей», который говорит о том, что объект не должен создавать зависимости внутри себя, а должен получать эти зависимости, например, в конструкторе. 
![[Pasted image 20240125141738.png]]
В Angular механизм «Внедрение зависимостей» работает по принципу:
- Во-первых, создаётся механизм регистрации зависимостей, который называется DI Container
- Во-вторых, создание объекта переносится на фабрику классов, называемую Injector

<font color="#f79646">В Angular, `providedIn` используется в декораторе `@Injectable()`, чтобы указать, где необходимо предоставить службу или сервис.</font>

Есть два основных способа использования `providedIn`:

1.    `providedIn: 'root'` - Это означает, что сервис будет доступен во всем приложении (синглтон). Он будет инициализирован только один раз, и этот же экземпляр будет использоваться каждый раз, когда он потребуется.

Пример:

```typescript
@Injectable({ 
  providedIn: 'root' 
})
export class MyService { 
  constructor() { }
}
```

2.    `providedIn: SomeModule` - Это означает, что сервис будет предоставлен только тогда, когда `SomeModule` загружен. Если модуль не загружен, сервисы также не будут загружены.

Пример:

```typescript
@Injectable({ 
  providedIn: SomeModule 
})
export class MyService { 
  constructor() { }
}
```

Важно помнить, что когда вы используете `providedIn` и предоставляете службы на уровне модуля или корневого уровня, вам не нужно добавлять их в поле `providers` ваших модулей.
#### providedIn: 'platform'

Это способ предоставления сервисов в Angular. Если сервис предоставляется на уровне платформы, это означает, что один и тот же экземпляр сервиса будет доступен глобально на протяжении всей платформы во всех приложениях и только один экземпляр этого сервиса будет создан.

Он отличается от `providedIn: 'root'`, который предоставляет сервис для единственного приложения. Сервис, указанный с использованием `providedIn: 'platform'`, будет существовать только в одном экземпляре для всех приложений на всей платформе.

Следует отметить, что использование `providedIn: 'platform'` наиболее полезно, когда у вас есть несколько Angular приложений, работающих на одной странице. В противном случае использование `providedIn: 'root'` обычно является предпочтительным выбором.

```typescript
@Injectable({
  providedIn: 'platform'
})
export class MyService {
  // service logic here
}
```
#### providedIn: 'any'

Это новый способ предоставления сервисов, который был добавлен в Angular версии 9.

Когда сервис предоставляется с использованием `providedIn: 'any'`, он становится доступен в любом модуле, который его запросит, но каждый модуль создает свой собственный уникальный экземпляр сервиса.

В отличие от `providedIn: 'root'` или `providedIn: 'platform'`, это позволяет каждому модулю иметь собственную изолированную копию сервиса.

Этот способ предоставления особенно полезен для лениво загружаемых модулей, потому что каждый из них будет иметь свой независимый экземпляр сервиса.

Пример:

```typescript
@Injectable({
  providedIn: 'any'
})
export class MyService {
  // service logic here
}
```

#### `providedIn: Type<any>`

Это способ предоставления сервиса на уровне конкретного модуля. Здесь `Type<any>` представляет тип модуля, которому мы хотим предоставить сервис.

Сервис будет доступен во всем приложении, но его экземпляр будет создан только тогда, когда модуль, указанный в параметре `providedIn`, загружается в приложение.

Это особенно полезно, когда у вас есть сервис, который должен быть доступен сразу после загрузки определенного модуля.

Пример:

```typescript
import { Injectable, Type } from '@angular/core';
import { MyModule } from './my.module';

@Injectable({ 
  providedIn: MyModule
})
export class MyService {
  constructor() { }
}
```

В этом примере, экземпляр `MyService` будет создан при загрузке `MyModule`, и этот экземпляр будет доступен везде в приложении.

--------

Angular зависит от системы инъекции зависимостей для предоставления зависимостей везде, где они нужны в приложении. Существуют два ключевых понятия связанные с этим - Extended Providers Config и Hierarchical Injectors. Здесь краткое объяснение каждого из них:

#### Extended Providers Config
Программируя на Angular вы определяете провайдеров (providers), которые создают экземпляры сервисов. В большинстве случаев вы просто предоставляете класс сервиса и Angular его инстанциирует. Однако, при помощи расширенных опций конфигурации провайдера вы можете управлять процессом создания экземпляра. Например, вы можете предоставить предопределенное значение, использовать фабричную функцию для создания сервиса, предоставить сервис, только когда он востребован, и так далее.

```ts
{
  provide: APP_CONFIG,
  useValue: HERO_DI_CONFIG
}
```

В этом примере мы используем `provide` для определения токена, по которому будет искаться сервис, и `useValue` для предоставления непосредственно заранее определенного значения.

#### Hierarchical Injectors
Это концепция, связанная с организацией системы инъекции зависимостей Angular. Инжекторы создаются иерархически, это значит, что каждый компонент имеет свой инжектор, и этот инжектор следует иерархии компонентов для поиска провайдера, если он не найден в локальном инжекторе компонента. Иерархия инъекторов структурирована так же, как и иерархия компонентов в вашем приложении, позволяя вам управлять областью видимости сервисов. То есть вы можете предоставлять сервисы глобально (в корневом Injector), на уровне модуля, или на уровне компонента, контролируя тем самым, где и как создаются экземпляры сервиса.

```ts
@Component({
  selector: 'app-root',
  providers: [HeroService], // Провайдер HeroService будет предоставлен только для этого компонента и его дочек
  template: `...`
})
export class AppComponent {}
```

Это создает новый экземпляр `HeroService` только для `AppComponent` и его дочерних компонентов.
#### Lazy Module Injectors
Angular поддерживает ленивую загрузку, что позволяет загружать модули и связанные с ними провайдеры (инъекции зависимостей) только когда они действительно необходимы. Каждый лениво загружаемый модуль создает свой собственный инжектор, который обычно дочерний инжектор для инжектора модуля приложения.
#### viewProviders
В Angular компонент имеет два типа инжекторов: <font color="#f79646">Element Injector и View Injector.</font> `providers` настраиваются на Element Injector в то время как 'viewProviders' настраиваются на View Injector. Если в Element Injector нет провайдера, он передает запрос родительскому инъектору, но View Injector передает запрос только себе и не лезет к родительскому инъектору. 

```typescript
@Component({
  selector: 'my-comp',
  providers: [Service], // Инжекторы элементов
  viewProviders: [Service], // Инжекторы представлений
  template: `
    <ng-content></ng-content>
  `
})

// Дочерние компоненты будут иметь доступ к провайдерам, но содержимое, проектированное с помощью <ng-content>, не будет иметь доступа к viewProviders.
```
#### Decorators
В Angular используются декораторы для обозначения классов, которые можно использовать с Angular DI. Например, `@Component`, `@Directive`, `@NgModule`, `@Injectable` и т.д. Декораторы указывают Angular какие объекты предоставить в качестве зависимостей для различных частей приложения.
#### Multi Providers
Angular позволяет предоставлять несколько значений для одного токена, используя опцию `multi` в конфигурации провайдера. 

```typescript
{ provide: "MyToken", useValue: 'Value 1', multi: true },
{ provide: "MyToken", useValue: 'Value 2', multi: true }
```

Результатом этого кода будет массив `['Value 1', 'Value 2']`, когда мы запросим инъекцию зависимости `MyToken`. Эта функциональность полезна, например, при определении нескольких хуков для одного и того же маршрута.