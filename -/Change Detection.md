#angular
```table-of-contents
```
#### Стратегии обнаружения изменений
 
Angular имеет две стратегии обнаружения:
##### <font color="#f79646">default</font>
##### <font color="#9bbb59">onPush</font>
``` typescript
@Component({
	selector: 'card',
	changeDetection: ChangeDetectionStrategy.OnPush
	template: ``
})
export class Card {}
```

Ручной запуск механизма обнаружения изменений:

Существует три метода ручного запуска механизма обнаружения изменений:

###### <font color="#f79646">detectChanges()</font> 
в`ChangeDetectorRef` который запускает обнаружение изменений <font color="#d99694">во view компонента и его дочерних компонентах</font> запоминая стратегию обнаружения изменений. Это может быть использовано в комбинации с <font color="#76923c">detach</font>() для реализации локальных проверок изменений
###### <font color="#f79646">ApplicationRef.tick()</font> 
который запускает обнаружение изменений <font color="#d99694">для всего приложения</font>, соблюдая стратегии обнаружения изменений всех компонентов
###### <font color="#f79646">markForCheck()</font> 
в`ChangeDetectorRef` который **не** запускает обнаружение изменений но помечает все OnPush предков для одноразовой проверки, либо как часть текущего или следующего цикла обнаружения изменений. Он запустит обнаружение изменений для отмеченных компонентов, даже если они используют стратегию OnPush

##### ChangeDetectorRef
- это сервис, предоставляемый Angular, который может быть использован для работы с механизмом обнаружения изменений. 

В Angular обнаружение изменений выполняется автоматически в большинстве случаев, но иногда может потребоваться более гибкое управление этим процессом, и здесь может быть полезен `ChangeDetectorRef`. 

пример:
```typescript
constructor(private cd: ChangeDetectorRef) { }
ngAfterViewInit() {
  this.cd.detectChanges();
}
```

`ChangeDetectorRef` обычно может быть полезен, когда вы работаете с <font color="#f79646">динамическим компонентом</font> или когда вы хотите иметь <font color="#f79646">больше контроля</font> над процессом обнаружения изменений для улучшения производительности.

#### ExpressionChangedAfterItHasBeenCheckedError 
в Angular обычно возникает, когда значение свойства, которое связано с представлением (view) изменяется после того, как представление было обновлено.

Angular использует концепцию обнаружения изменений для отслеживания и обновления состояния приложения. Он выполняет это в две фазы: `doCheck` и `AfterViewChecked`.

`doCheck` - это фаза, когда Angular обновляет все свойства, связанные с представлением.

`AfterViewChecked` - это момент после отрисовки представления, когда Angular проверяет все свойства, связанные с представлением, на наличие изменений после `doCheck`.

Если Angular обнаруживает, что свойство изменилось после этой фазы `AfterViewChecked`, он выдает ошибку `ExpressionChangedAfterItHasBeenCheckedError`.

Часто такая ошибка может произойти, если в хуке жизненного цикла `ngAfterViewInit` или `ngAfterViewChecked` произошло изменение значения, которое связано с представлением.

Лучший способ избежать этой ошибки - это инициализировать все свойства, связанные с представлением, до того, как представление будет впервые обновлено. Если это невозможно, то можно обновить состояние асинхронно с использованием `setTimeout`, `Promise.resolve` или `this._ngZone.run()`.