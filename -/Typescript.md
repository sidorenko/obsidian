#typescript 
```table-of-contents
```
#### Types
У Typescript есть встроенные типы данных (такие как <font color="#4bacc6">number, string, boolean, и т.д</font>.), но он также позволяет определять сложные типы, а также использовать определенные типы для определенных переменных и функций. Это улучшает надежность кода и предотвращает множество ошибок, которые могут произойти во время выполнения.

#### Classes
Классы в TypeScript, как и в других языках с объектно-ориентированной парадигмой, являются шаблонами для создания объектов. Они могут иметь свойства и методы, а также могут использовать наследование [[Typescript OOP]] для повторного использования и расширения кода.

#### Interfaces
Интерфейсы в TypeScript используются для типизации объектов. TypeScript проверяет соответствие формы значения его типу (структурная система типов). Это позволяет задать форму объекта, и её можно использовать везде, где требуется этот тип объекта.

#### Decorators
Декораторы - это специальная функция, которая добавляет дополнительный код к определенным частям TypeScript кода, например, классам, методам и свойствам. Это может быть полезно для добавления мета-данных, переопределения значений или изменения поведения.

#### 'any'
`any` тип данных используется для отключения проверки типов в TypeScript. Это может быть полезно, когда вы работаете с динамическим JS кодом или со сторонними библиотеками. Однако, использование `any` может привести к потере всех преимуществ TypeScript, поэтому рекомендуется использовать его как можно менее возможно.

#### Compile Time Checks
TypeScript проверяет типы во время компиляции и выдает ошибки при несоответствии типов. Это позволяет избежать большинства ошибок, связанных с типами данных, которые обычно возникают во время выполнения в JavaScript.

#### Runtime Result
Несмотря на то, что TypeScript добавляет строгую типизацию и другую функциональность, в конечном итоге он компилируется в обычный JavaScript и не предоставляет никакой дополнительной функциональности во время выполнения. Компилированный JavaScript код затем исполняется в среде выполнения JS (браузер или Node.js).
#### Object

В TypeScript `object` является типом, который относится к не примитивным типам. Это значит, что все что не является number, string, boolean, symbol, null, или undefined.

```typescript
let obj: object;
obj = { key: "value" };  // Допустимо
obj = 42;                // Ошибка, потому что 42 является примитивом
```

#### Never

`never` это тип, который используется в функциях, которые никогда не возвращают значение. К примеру, функция, которая всегда выбрасывает ошибку.

```typescript
function error(message: string): never {
  throw new Error(message);
}
```

#### Void

`void` это тип, который обычно используется в функциях, которые не возвращают значение.

```typescript
function log(message: string): void {
  console.log(message);
}
```

#### Union

Union типы позволяют объявить переменную, которая может быть одного из нескольких типов. Это позволяет иметь гибкость в работе с типами данных.

```typescript
let id: number | string;
id = "123";  // Допустимо
id = 123;    // Допустимо
```

#### Intersection

Intersection типы позволяют комбинировать несколько типов в один. Это позволяет создавать сложные типы, которые включают в себя все свойства и методы входящих типов.

```typescript
type First = { a: number };
type Second = { b: string };

type Combined = First & Second;

let obj: Combined;
obj = { a: 1, b: "value" }; // Допустимо
```

#### Basic Generic types

Generic типы позволяют создавать универсальные функции и классы, которые могут работать с различными типами данных.

```typescript
function identity<T>(arg: T): T {
  return arg;
}

console.log(identity<number>(1)); // Вернет 1
console.log(identity<string>("string")); // Вернет "string"
```
#### Type Guard
Type Guard - это выражение, которое выполняет проверку типов и гарантирует определенный тип переменной в определенной области видимости. 
В Typescript вы можем использовать операторы `typeof`, `instanceof` и `in`, пользовательские проверки на тип, проверки на дискриминационные юнионы и другие методы для создания type guard'ов.

```typescript
let value: string | number;

if (typeof value === "string") {
  // В этом блоке TypeScript знает, что value - это строка
  value.toUpperCase();
} else {
  // В этом блоке TypeScript знает, что value - это число
  value.toFixed(2);
}
```
В этом примере `typeof value === "string"` служит гардом типов, указывающим Typescript, что значение внутри этого условного блока является строкой.

#### Advanced Generics

Advanced Generics в TypeScript позволяют еще больше контролировать и ограничивать типы. С помощью продвинутых дженериков вы можете создавать сложные и реюзабельные абстракции. Вот некоторые продвинутые концепции:

##### Conditional Types
позволяет использовать тернарные операторы с типами.

```typescript
type IsString<T> = T extends string ? true : false;

type A = IsString<number>;  // false
type B = IsString<string>;  // true
```

##### Type inference in generics
позволяет выводить типы из дженерика.

```typescript
type ReturnTypeOf<T> = T extends (...args: any[]) => infer R ? R : any;

type Func = () => string;

type Test = ReturnTypeOf<Func>;  // string
```

##### Mapped Types
позволяет использовать идентификаторы с типами, которые проходят через другие типы и преобразовывают их.

```typescript
type MappedType<T> = {
    [P in keyof T]: T[P] | null;
};

type Test = MappedType<{ a: number, b: string }>;  // { a: number | null, b: string | null }
```

##### Keyof and Lookup types
позволяет извлекать ключи объекта в виде свойства и использовать их в дженериках.

```typescript
type Point = { x: number; y: number };
type P = keyof Point;  // "x" | "y"
type Q = Point["x"];  // number
```