> [!quote]- LINKS
>#### Reference 
>(ссылка на внешнюю литературу)
>
> [35 вопросов на собес](https://habr.com/ru/post/578370/)
> [RoadMap](https://roadmap.sh/javascript)



![[JS Map.canvas|canvas mindmap JS]]

> [!quote]- Interview Questions by levels:

### Novice (Junior)
**Arrays**

- Array literals
- Know several options how to create Array
- Array length
- Know how Array length property works

**Variables, Values, Data Types**

- Variables
- Know how to declare variables
- Values
- Know how to assign values to variables
- Literals
- Know basic String, Number, Object, Array literals
- Primitive Data Types
- Discover primitive data types

**Objects**

- Object literals
- Know several ways how to create object

**Functions**

- Function declaration/expression
- Know both Function expression and Function declaration
- Be able to explain declaration/expression differences

**Closures Basics**

- Nested functions
- Able to create nested functions
- Understand variables visibility for nested scopes

### Intermediate (Middle)
**Objects Built-in methods**

- Know how to use built-in methods
- Know static Object methods

**Object as Hash**

- Be able to use Object as a Hash
- Be able to loop though Object keys

**Arrays Built-in methods**

- Know how to copy array
- Know how to copy array part
- Know how to modify array

**Arrays Iterating, Sorting, Filtering**

- Know how to sort Array
- Be able to custom sorting for Array
- Be able to filter Array elements
- Know several method how to iterate Array elements
- Be able to compare Hash and Array performance

**Functional Scope**

- Know global scope and functional scope
- Know variables visibility areas Understand nested scopes and able work with them

**Functions Parameters / Arguments**

- Know how to define Function parameters
- Know difference between parameters passing by value and by reference
- Know how to handle dynamic amount of Function parameters

**ECMAScript Intermediate**

- Function default parameters
- Discover default parameters concept and limitations
- Spread operator for Function
- Know how to use spread operator for Function arguments
- Be able to compare [arguments] and spread operator
- Spread operator for Array
- Understand and able to use spread operator for Array concatenation Destruction
- Be able to discover destruction concept
- Understand variables and Function arguments destruction
- String templates
- Know String template syntax and rules
- [for..of] loop
- Know how [for..of] loop works
- Be able to compare [for..of] loop with other types of loops

**Advanced Expressions**

- Hoisting
- Understand hoisting concept
- Able to use hoisting in development
- Auto data type conversion
- Know rules of auto data types conversion
- Be able to discover cases of implicit data types conversion into boolean, string, number
- Strict comparison
- Be able to discover difference between strict and non-strict comparison
- Be able to provide use cases of both types of comparison

**Advanced Functions**

- Arguments
- Understand [arguments] and dynamic amount of parameters
- Be able to use [arguments], retrieve additional parameters
- [this] scope
- Understand difference between function and method
- Understand how [this] works, realize [this] possible issues
- Manage [this] scope
- Be able to replace [this] scope
- Be able to use [call] and [apply]
- Function build-in methods

**Functional Patterns**

- Immediate function
- Know immediate function pattern
- Be able to explain the purposes of immediate function usage
- Callback (Function as argument)
- Know callback pattern
- Understand callback limitations (callback hell)
- Binding
- Know how to bind [this] scope to function
- Be able to provide cases when it's required

**Closures Advanced**

- Context (lexical environment)
- Understand function creation context (lexical environment)
- Be able to explain difference between scope and context
- Inner/outer lexical environment
- Understand lexical environment traversing mechanism
- Understand connection between function and lexical environment
- Be able to discover cases where lexical environment required
- Be able to create and use closures

**Object Oriented Programming**

- [new] keyword
- Understand how [new] keyword works
- Understand the difference in calling function with/without [new] keyword
- Function constructor
- Know function constructor concept
- Know function constructor pattern
- Able to create constructor functions
- Public, private, static members
- Know how to create public members
- Know how to create private members
- Know how to create static members
- Understand OOP emulation patterns and conventions

**Prototypal Inheritance Basics**

- [__proto__] property
- Understand [__proto__] object property
- Understand how interpreter traverses object properties
- Able to work with object [__proto__]
- Able to use [Object.create] and define [__proto__] explicitly
- Able to set / get object prototype
- [prototype] property
- Know function [prototype] property
- Understand dependency between function constructor [prototype] and instance [__proto__]
- Able to create 'class' methods using function [prototype] property

**ECMAScript Classes**

- Class declaration
- Know [class] declaration syntax
- Know how [class] declaration works under the hood
- Understand difference between [class] and function constructor
- Understand difference between method and [class] method
- Be able to develop in OOP style using [class] declaration
- [constructor] keyword
- Inheritance
- Know [extends] syntax and how it works
- Getter/setter
- Be able to create getter/setter
- [class] methods

**Functional Inheritance**

- Rent a constructor Know functional inheritance pattern
- Be able to explain difference between functional and prototypal inheritance
- Be able to discover benefits and drawback of both prototypal and functional inheritance
- Mix-ins Know mix-in pattern
- Know mix-in specific and limitations
- Able to explain benefits and drawbacks comparing with inheritance

**Regular Expressions Basics**

- String methods
- Know String methods for regular expressions
- Understand regular expressions performance issues
- RegExp methods and flags
- Metacharacters
- Quantifiers

**ECMAScript Data Types & Expressions**

- Object [keys/values]
- Object calculated props
- [Symbol] data type
- Know [Symbol] data type specific
- Be able to explain difference between usual object key and symbol
- [Set/Map] data types
- [WeakSet/WeakMap] data types

**JavaScript Errors**

- [try..catch] statement
- Know how to handle errors
- Be able to explain [try..catch] performance issues
- Throw errors
- Custom errors

**ECMAScript Advanced**

- Promises
- Know how [Promise] works
- Know promise chain pattern
- Be able to compare promise and callback patterns
- Be able to handle errors in promises
- Be able to use promisification pattern
- Iterators
- Know [Iterator] interface
- Be able to create custom iterator
- Generators Know generator syntax
- Be able to compare generator and iterator
- Understand how [yield] works
- Understand plain async code

### Advanced (Senior)

**Object Property Descriptor**

- Know how to use property descriptors
- Be able to explain enumerable, configurable, writable property attributes
- Be able to create property getter/setter

**Functions Recursion**

- Know recursion concept and able to use it
- Able to explain recursion risks, benefits and drawbacks

**Advanced Functional Patterns**

- Chaining
- Know chaining pattern and cases where it will be useful
- Currying
- Know how to bind arguments to function
- Memorization
- Know memorization optimization
- Understand problem with non-primitive arguments memorization

**Prototypal Inheritance Advanced**

- Temporary constructor
- Know prototypal inheritance mechanism
- Know prototypal inheritance temporary constructor pattern
- Be able to explain prototypal chain from instance to its 'class' and 'class' parent
- Be able to develop in OOP style using prototypal inheritance pattern
- [instanceof] operator
- Be able to use [instanceof] operator
- Know how [instanceof] operator works

**ECMAScript Classes Advanced**

- [super] keyword
- Understand [super] reference
- Able to use [super] reference (in constructor, in class methods)
- [static] keyword
- Know static members concept
- Be able to create [class] static properties and methods

**Regular Expressions Advanced**

- Ranges
- Grouping
- Greedy and lazy search
- Replacements

### Expert 

JavaScript Deep Dive

- Clear understanding of the architectural principles and can choose right framework for particular project to be able to write code that can be easily maintained




#list
[[types - NUB NOS]]
[[variables - var, let, const]]
[[context - this, call, apply]]
[[hoisting - всплытие]]
null, undefined, undeclared
[[string methods]]
[[object methods]]
[[array methods]]
деструктуризация
область видимости
[[promises]]
[[functions - IIFE, anonym, async (setTimeout), hight order, ]]
closure - замыкание
[[OOP]]

[[атрибуты HTML vs свойства JS]]
[[operators]]
[[сallbacks vs promises api vs async/await]]
[[class vs function constructor]]
[[generators, iterators]]



## Список файлов по тегу
```dataview
list from #js SORT file.name ASC
```


> [!question] QUESTION IN ANKI FLASHCARD

#flashcards-js
#### Чому <span style="background:#fdbfff">typeof null</span> повертає object?

#### Що таке явне і неявне <span style="background:#fdbfff">приведення</span> (перетворення) типів даних у JS? Як відбувається перетворення типів у таких прикладах:

#### Output
``` js
{}+[]+{}+[1]

!!"false" == !!"true"

['x'] == 'x'
```
?
``` js
false
```

#### Розкажіть про тип даних <span style="background:#fdbfff">Symbol</span> і його практичне застосування. Як перевести число з 10-розрядної системи в 16(2,8)-розрядну систему числення?

#### Як перевірити, чи число є <span style="background:#fdbfff">скінченним</span>?

#### Як перевірити, що змінна рівна <span style="background:#fdbfff">NaN</span>?

#### Чим відрізняється поведінка <span style="background:#fdbfff">isNaN</span>() та Number.isNaN()?

#### Чи можна записувати <span style="background:#fdbfff">нові властивості </span>/ функції в прототипи стандартних класів (Array, Object тощо)? Чому ні? У яких випадках це робити можна? Як убезпечити себе, якщо потрібно розширити прототип?

#### Назвіть <span style="background:#fdbfff">методи масивів</span>, для чого вони потрібні.

#### Чому не варто використовувати <span style="background:#fdbfff">конструктори</span> типу <span style="background:#fdbfff">new String</span>?

#### В чем смысл <span style="background:#fdbfff">оборачивания</span> всего содержимого JavaScript-файла в функцию?
?
Этот шаблон называется IIFE - Immediately Invoked Function Expression (немедленно вызываемое функциональное выражение). Этот подход позволяет:

- обеспечить коду собственный блок видимости, то-есть контекст выполнения
- избежать загрязнения глобальной области видимости глобальными переменными
- избежать неумышленного переопределения уже существующих переменных в глобальной области видимости

#### В чем смысл и польза указания `use strict` в начале JavaScript-файла?
?
Команда `use strict` включает так называемый строгий режим. В этом режиме предупреждения становятся ошибками, что помогает в написании более чистого и безопасного кода, менее уязвимого к ошибкам в продакшене.
   
#### Что такое `NaN`? Какого типа это значение? Как можно узнать, равно ли значение переменной `NaN`?
?
`NaN` расшифровывается как "Not A Number", это "falsey" (ложное) значение.
Выражение typeof `NaN` возвращает тип `Number`.
Проверить значение переменной на соответствие `NaN` можно, воспользовавшись встроенным методом `isNaN()` или используя оператор тройного равенства ===

#### Что такое <span style="background:#fdbfff">замыкание</span> в JavaScript?
?
Замыкание в JavaScript - это комбинация функции и лексического окружения, в котором она была определена. Это позволяет ей обращаться к переменным и функциям этого лексического окружения в дальнейшем.
В следующем примере мы определяем функцию `makeCounter()`, которая фактически является фабричной функцией. При вызове она возвращает дочернюю функцию, которая имеет доступ к лексическому окружению внешней функции, то-есть функции `makeCounter()`. Таким образом, возвращаемая функция запоминает переменную `counter` и в последующем изменяет ее значение.
``` js
    function makeCounter(initial = 0) {
      let counter = initial;
    
      return function() {
        return counter += 1;
      }
    }
    
    const counterA = makeCounter(0);
    
    console.log(counterA()); // 1
    console.log(counterA()); // 2
    
    const counterB = makeCounter(100);
    
    console.log(counterB()); // 101
    console.log(counterB()); // 102
    ```

#### Как можно <span style="background:#fdbfff">клонировать</span> объект?
?
Можно использовать оператор остатка `...`
Можно использовать `Object.assign(newObj, oldObj)`.
Но эти подходы не позволяют выполнить глубокое клонирование. Поэтому, если нам нужно клонировать объект со вложенными объектами, мы можем использовать либо метод какой-либо библиотеки (привет, lodash), либо сделать это средствами встроенного объекта `JSON`.
 ``` js
 JSON.parse(JSON.stringify(objectToClone))
    ```

#### Как можно добавить элемент в начало и в конец массива?
?
Чтобы добавить элемент в начало массива, можно использовать 
`Array.prototype.unshift()`. 
Для добавления элемента в конец массива подойдет 
`Array.prototype.push()`.
   
#### В чем разница между `undefined` и `is not defined`?
?
`undefined` - это значение, присваемое объявленной, но не проинициализированной переменной. 
Мы получаем `undefined`, обращаясь к существующей переменной. А в случае обращения к несуществующей (необъявленной) переменной, мы получим ошибку `is not defined`.

#### Как проверить, является ли объект массивом?
?
Для этого можно использовать встроенный метод `Array.isArray()`.

#### Что такое hoisting (поднятие) в JavaScript?
?
Поднятие - это поведение компилятора JavaScript, заключающееся в поднятии объявлений переменных и функций в начало области видимости.  
Благодаря поднятию мы можем использовать функции и переменные до их объявления в коде. Однако, следовать учитывать, что поднимаются только объявления, но не присваивания значений.  
По этой причине, например, мы можем использовать до объявления функцию, объявленную через `Function Declaration`, но не можем ту, которая объявлена через `Function Expression`.
  
#### Что такое `this`?
?
`this` указывает на объект области видимости во время выполнения. По умолчанию `this` указывает на глобальный объект. В браузере выражение `this === window` будет истинно.
   
#### Как работает прототипное наследование?
?
Если отвечать кратко, в JavaScript все является объектами. Эти объекты связаны цепочками прототипов, по которым им передаются методы и свойства. При обращении к свойству или методу объекта сначала происходит поиск этого свойства у самого объекта. В случае неудачи поиск перенаправляется в его прототип, затем в прототип прототипа и так далее, пока искомое свойство не будет найдено, либо пока не закончится цепочка прототипов.
   
#### Объясните, почему запись `function foo(){}()` вызывает ошибку и не работает, как IIFE?
?
 Здесь дело в том, что круглые скобки вызова функции добавлены сразу после `Function Declaration`. Однако, они могут следовать только за выражением (expression). Поэтому мы должны либо прибегнуть к варианту с `Function Expression`, либо обернуть `Function Declaration` в скобки, тем самым превратив его в выражение.
``` js
    const foo = function(){}()
    // либо
    (function foo(){})()
    // либо со стрелочной функцией
    (() => {})()
    ```

#### В чем разница между `null`, `undefined` и `undeclared`?
?
`null` - это в прямом смысле "ничего". Можно использовать это значение в качестве плейсхолдера.
`undefined` - это значение для случая "объявлено, но не инициализировано".
`undeclared` - это ошибка, возникающая в случае обращении к необъявленной переменной.
   
#### В чем разница между `Array.prototype.forEach` и `Array.prototype.map`?
?
 `Array.prototype.forEach` - это инструмент обхода цикла процедурно, а `Array.prototype.map` - функционально.
 `.forEach` просто проходится по массиву с выполнением переданного обратного вызова на каждой итерации, а `.map` создает и возвращает новый массив на основе исходного, выкладывая по кирпичику на каждой итерации.
   
#### В каких случаях используются <span style="background:#fdbfff">анонимные</span> функции?
?
Анонимные функции чаще всего используются в качестве функций обратных вызовов. Также, каждая стрелочная функция является анонимной.
  
#### Объясните разницу между `const person = Person()` и `const person = new Person()` при `function Person(){}`
?   
Если функция `Person()` не возвращает явным образом создаваемый экземпляр, то вариант `const person = Person()` присвоит константе `person` значение `undefined`, поскольку именно таков результат `void` функции.
Если функция `Person` явным образом возвращает экземпляр, он станет значением константы `person` при `const person = Person()`.
Однако, вариант с использование оператора `new` "выигрывает", поскольку он устанавливает корректную связь объекта `person` с цепочкой прототипов `Person`, в то время как выражение `const person = Person()` просто присваивает константе результат вызова функции.

#### В чем разница между `Function.prototype.call` и `Function.prototype.apply`?
?
Оба метода вызывают исходный метод с подмененным контекстом, но .`call` принимает параметры через запятую, а `.apply` - массивом.
   
#### Как работает `Function.prototype.bind`?
?
Данный метод возвращает функцию, по отношению к которой он вызывается, но с подмененным контекстом.

#### Что вы знаете об <span style="background:#fdbfff">AJAX</span>?
?
 AJAX = Asynchronous Javascript And XML. Это подход к асинхронному (неблокирующему) обмену данными с сервером.
 Изначально для решения подобной задачи использовался объект `XMLHttpRequest` **,** сейчас же более актуален дружелюбный к обещаниям (Promise) `fetch API`.

#### В чем разница между <span style="background:#fdbfff">атрибутами</span> и <span style="background:#fdbfff">свойствами</span>?
?  
Атрибут - это HTML-термин, в то время как свойство - термин из JavaScript. Иными словами, если речь идет о значении в HTML-разметке, мы говорим об атрибуте. Однако, если имеется в виду свойство объекта, к которому мы получили доступ средствами JavaScript - вернее называть это свойством.

#### В чем разница между == и === ?
?
Оператор двойного равенства производит приведение типов, оператор строгого равенства - нет.

#### Почему лучше оставлять глобальную область видимости "как есть" и не трогать ее?
?
По той причине, что свойства глобальной области видимости может изменить любой JavaScript-код, имеющий к ней доступ. Также, это грозит конфликтами имен.
   
#### Что такое <span style="background:#fdbfff">SPA</span> и как сделать его SEO-friendly?
?
Single Page Application - это реализация веб-приложения таким образом, чтобы при первой загрузке пользователь получал все ресурсы, необходимые для того, чтобы избавиться от загрузки страницы с нуля при совершении интерактивных действий с интерфейсом.  Основную роль в SPA играет JavaScript, реализующий механизмы динамического обновления данных без перезагрузки страницы.
Для того, чтобы сделать SPA SEO-friendly, можно обратиться к таким решениям, как предварительный рендеринг или серверный рендеринг.
   
#### Какие преимущества и недостатки у использования Promise API вместо обратных вызовов?
?
Обещания избавляют разработчиков от ада обратных вызовов, но это не единственное их достоинство. Важно также отметить, что пользуясь обратными вызовами, мы зачастую были вынуждены "верить" стороннему коду. А вызовет ли он наш коллбэк? А вызовет ли он его корректное количество раз? А не вызовет ли он его слишком рано или слишком поздно?
Представьте, что функция, снимающая деньги со счета пользователя, передается коллбэком в сторонний (в той или иной степени) код. Что будет, если он вследствие внесенных со стороны изменений начнет вести себя некорректно и, скажем, начнет вызывать эту функцию пять раз вместо одного? Используя обещания, мы сами властны над нашим кодом. Мы сначала дожидаемся результата вызова сторонней функции, возвращающей обещание, а потом передаем управление необходимому блоку кода. Обещание может быть разрешено один раз и с тех пор оно неизменно, так что надежность нашего кода резко возрастает.

#### Какие инструменты вы используете при отладке?
?
При первой встрече с проблемой я, не спеша усложнять себе жизнь, обращаюсь к `console.log`. Если это не помогает, вызываю тяжелую артиллерию в виде браузерного отладчика.
   
#### Какие конструкции языка вы используете для обхода массивов и объектов?
?
В случае с массивами, это чаще всего `forEach` и `map`. Реже возникает необходимость в `for`, `for in`, `for of`, `reduce`, `filter` и подобных.  А чтобы обойти объект, понадобится немного изобретательности. Один из вариантов - получить ключи с помощью `Object.keys`, по которым впоследствии пройти с помощью `forEach`. Либо же можно воспользоваться `Object.values`, `Object.entries`, `Object.keys`.

#### Объясните разницу между <span style="background:#fdbfff">изменяемыми</span> и <span style="background:#fdbfff">неизменяемыми</span> значениями
?
Значения примитивных типов (например, строка или число) не могут быть изменены после того, как попали в память. Значения объектных типов (объекты, массивы) могут изменяться в ходе работы программы.

#### Объясните разницу между <span style="background:#fdbfff">синхронными</span> и <span style="background:#fdbfff">асинхронными</span> функциями
?
JavaScript - это однопоточный язык, то-есть функции выполняются в синхронном порядке. Приложение блокируется на время выполнения каждой конкретной функции. Так происходит по той причине, что JavaScript имеет только один стек вызовов. С другой стороны, есть асинхронный способ выполнения функций, когда мы не блокируем весь интерфейс благодаря тому, что не дожидаемся выполнения функции, а подписываемся на событие с передачей обратного вызова. Ну, или мы можем иметь дело с обещанием или с прочими внешними API вроде setTimeout. В таком случае браузер помещает обработчик события в очередь задач, а когда наступает время его вызвать, он перемещает его в стек вызовов.

#### Что такое цикл событий? В чем разница между стеком вызовов и очередью задач?
?
<span style="background:#fdbfff">Стек вызовов</span> - это структура данных (первым вошел, последним вышел), используемая для отслеживания порядка выполнения функций в текущем контексте (области видимости).   <span style="background:#fdbfff">Очередь задач </span>- это структура данных (первым вошел, первым вышел), используемая для отслеживания выполнения асинхронных функций, готовых оказаться в стеке вызовов.
<span style="background:#fdbfff">Цикл событий</span> - это механизм, на каждом тике выполняющий функции из стека вызовов и, если он оказывается пустым, перемещающий задачи из очереди задач в стек вызовов для выполнения.

#### В чем разница между `let`, `const` и `var`?
?
`var`   
-   поднимается в начало области видимости функции при компиляции     
-   объявляет переменную, которая может быть перезаписана        
-   объявляет переменную, которая может быть переопределена        
`let`
-   поднимается в начало области видимости блока при компиляции
-   объявляет переменную, которая может быть перезаписана
-   объявляет переменную, которая не может быть переопределена    
`const`
-   поднимается в начало области видимости блока при компиляции
-   объявляет переменную, которая не может быть перезаписана или переопределена
  
#### В чем разница между ES6 `class` и ES5 `function constructor`?
?
Классы, добавленные в стандарте EcmaScript 6, всего лишь синтаксический сахар поверх всем известных прототипов.  В работе эти подходы отличаются уровнем абстракции, который ожидаемо выше у классов - разработчику не приходится напрямую работать с прототипами.

#### Что такое функция высшего порядка?
?
Функция, принимающая функцию обратного вызова в качестве аргумента.
  
#### Что такое <span style="background:#fdbfff">DOM</span>?
?
DOM - Document Object Model (объектная модель документа). Другими словами, это дерево всех узлов страницы, которые распознал браузер в процессе обработки HTML-разметки. DOM - это интерфейс, позволяющий JavaScript-коду взаимодействовать с шаблоном.

#### В чем разница между областью видимости функции и блочной областью видимости?**
?
И то, и то является полноценной областью видимости. Различие наблюдается при использовании ключевого слова `var`, которое ограничивается только областью видимости функции, но не блочной областью видимости.
  
#### Что произойдет в результате выражения `var foo = 10 + "20"` и почему?
?
Переменная foo примет значение "1020".  В JavaScript это поведение называется <span style="background:#fdbfff">приведением</span> типов. Если хотя бы один из операндов является строкой, второй также будет преобразован в строку.