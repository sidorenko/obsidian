#list 

[Run online in Forefox](https://stackblitz.com/edit/rxjs-asyncsubject-w85fto?devtoolsheight=100&file=index.ts)
[Run online with console output](https://rxfiddle.net)

[subjects](https://www.javatpoint.com/rxjs-subjects)

```dataview
list from #rxjs
```
![[RxJS.canvas]]
--------

#flashcards-rxjs

#### <span style="background:#fdbfff">cold / hot</span> observables
?
kj
<!--SR:!2023-11-29,1,228-->

#### mergeMap concatMap switchMap
?
ll
<!--SR:!2023-11-29,1,228-->

#### subjects types
?
Subject
AsyncSubject - complete()
ReplaySubject(3)
BehaviorSubject('init value')
<!--SR:!2023-11-29,1,230-->

#### unsubscribe
?
jjj
<!--SR:!2023-11-29,1,228-->

#### Imperative vs Reactive Programming & Pull vs Push
?
<span style="background:#ff4d4f">императивное</span> - при смене одной из переменной результат не меняется.
<span style="background:#ff4d4f">реактивное</span> - подхватывает на лету и результат меняется.
<span style="background:#ff4d4f">пул пуш</span> - В паттернах проектирования ПО часто применяются так называемые push- и pull- модели последовательной обработки данных. Под последовательной обработкой данных понимаются цепи обработки информации, в которых каждое звено делает свою работу и передает данные следующему в цепочке.
Push-модель подразумевает вызовы в сторону, сонаправленную с передачей данных. Pull-модель подразумевает вызовы в противоположную сторону. Говоря другими словами, в Push модели каждое звено вызывает следующее, как только у него готовы данные на выход. В Pull модели каждое звено вызывает предыдущее, как только ему нужна следующая порция данных.
Бывают также и звенья-переходники. pull в push конвертируется очень просто и такие модули, как правило легче реализовать. push в pull конвертируется сложнее всего, нуждается в буферизации и обработки underflow-случаев.
Нюансы в построении той или иной архитектуры возникают в первую очередь при необходимости блокировать вызовы. В pull модели, как правило, всвязи с недостатком данных в первом звене (например при приеме по сети). В push модели, как правило, всвязи с невозможностью принять данные в последнем звене (например, при передаче по сети).
Также архитектура усложняется проблемой выделения буферов под output-данные на каждом звене - при обработке большого кол-ва данных необходимо минимизировать дополнительные холостые копирования данных.
<!--SR:!2023-11-29,1,230-->

#### Caching response
?
jndtn: pipe(shareReplay(1))
сохранение одного последнего запроса
<!--SR:!2023-11-29,1,230-->
